1.	Program type:
	Running the command `file ./level2` we see the file is 32-bit ELF
	executable.
	Running the command `checksec --file ./level2, we see that the stack is
	executable (NX disabled).

2.	Content:
	There's two function ['main', 'p'], 'main' calls 'p' and return.

	'p' use fflush(3) to clear the stdout and then fills a buffer with size 
	56 bytes (Again, gets(3) is vulnerable because it doesn't have a stopping 
	condition other than '\0').

	An if condition is used to check if the return address of the 'main' 
	function starts with 0xb, this could be considered as a way to check if the
	saved-eip of the 'p' function was overwritten using gets(3) with something 
	else other than the address that was meant to be there (the return address 
	pushed on the stack from the function 'main').

	If the saved-eip is changed, it printf(1) the changed address and calls 
	exit(3). Otherwise, it puts(3) the content of the buffer and duplicate it 
	with strdup(3) (for no particulare reason), which means the heap now 
	contains the content of the buffer.

3.	Solution:
	There's two ways to exploit this binary, both of'em are buffer overflows. 

	strdup(3) duplicates the buffer on the heap, the buffer contains a 
	shellcode that spawns a shell when it's executed and a address of the 
	duplicate in the heap that overwrite the saved-eip. Since the address of 
	the heap don't start with 0xb we pass the mask validation and when the ret 
	instruction executes our shellcode.

	Meanwhile, a normal stack buffer overflow won't work directly because of 
	the mask validation, so we'll push two addresses on the stack and calling 
	the return instruction twice, so when the mask validation occures, it'll 
	find a correct address (not starting with 0xb) and the second address will 
	jump to a memory area in the stack where our shellcode lies.

